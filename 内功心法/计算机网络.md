# 计算机网络笔记整理

## 一. 协议层次以及它们的服务类型

### 1.三种不同的模型标准

![image-20210223140357835](/Users/dinl/Library/Application Support/typora-user-images/image-20210223140357835.png)

五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构`只是为介绍网络原理`而设计的，实际应用还是 TCP/IP 四层体系结构。

#### 1.1 OSI模型

OSI(Open System Interconnection Model): 开放式系统互联模型,是ISO(国际标准话组织)提出的世界范围内的网络互联标准框架,在OSI模型中,网络体系架构被分为7层,每层实现各自的功能和协议,并完成==相邻层==的接口通信.各层提供的服务与这些服务如何实现无关.

* **7.应用层(Application)**

  作用:通过应用程序之间的交互来完成特定的网络应用.

  协议: **HTTP**, TFTP, FTP, NFS, WAIS, SMTP

* **6.表示层(Presentation)**

  作用: 通信的应用程序能够解释交换数据的含义,定义了应用进程之间的交互规则

  协议: Telnet, Rlogin, SNMP, Gopher

* **5.会话层(Session)**

  作用:负责建立、管理和终止表示层实体之间的通信会话

  协议: SMTP, DNS

* **4.传输层(Transport)**

  作用: 主要任务是为两台主机进程之间的通信提供服务

  协议: **TCP/UDP**

* **3.网络层(Network)**

  作用:主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送

  协议: **IP**, ICMP, ARP, RARP, RIP, BGP

* **2.数据链路层(Data Link)**

  作用:数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧,丢帧指的是在此层丢弃检测出来的差错数据帧;

  协议: FDDI, Ethernet, Arpanet, PDN, SLIP, PPP

* **1.物理层(Physical)**

  作用: 保证网络设备的物理连接,确定传输媒体接口一些特性(机械特性、电气特性、功能特性，过程特性)

  协议: IEEE 802.1A, IEEE 802.2 ~IEEE 802.11

==OSI模型的优缺点==

* 优点: 制定的是国际化**规范标准**;
* 缺点: 模型结构复杂,部分功能冗余,导致完全实现OSI模型的系统不多

#### 1.2 TCP/IP四层参考模型

 上面提到OSI模型结构复杂冗余,所以出现了对于市场需求更友好的四层模型,它将七层模型简化到四层,一经提出便得到了广泛应用.

* **4.应用层**

  TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等

* **3.传输层**

  该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。

* **2.网际互联层**

  网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。

* **1.网络接入层**

  网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。

  

#### 1.3 OSI模型与TCP/IP模型比较

* 相同点

1. OSI与TCP/IP都采用了分层结构
2. 都能够提供面向连接和无连接两种通信服务机制

* 不同点

1. OSI是7层,TCP/IP是四层结构;
2. TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分;
3. OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络;
4. TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准;
5. OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的;

## 二.应用层(应用层+表示层+会话层)

### 1. HTTP协议

HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应的==应用层==协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以**明文发送**，不通过任何方式的数据加密。**当通信结束时，客户端与服务器关闭连接**。

#### 1.1 HTTP的不同版本

 1. **HTTP/0.9  (1991年)** 

    * 只有==GET==

      ```
      GET /index.html
      ```

    * 服务器只能回应HTML格式的字符串,不能回应别的格式

      ```shell
      <html>
        <body>Hello World</body>
      </html>
      ```

    * 服务器发送完毕,就关闭TCP连接,没有所谓的四次挥手

 2. **HTTP/1.0 (1996年)**

    * 可以发送任何格式的内容,使互联网不仅可以传输文字,还能传输图像,视频,二进制文件

    * 除了==GET==,还引入了==POST==,==HEAD==

    * 请求必须包含HEAD,头信息用来描述一些元数据(包括客户端信息)

      ```shell
      GET /index.html HTTP/1.0
      User-Agent: Mozilla/5.0(Macintosh;Intel Mac OS X 10_10_5)
      Accept: */*
      ```

    * 回应信息也必须携带HEAD信息,包括状态码,字符集支持,编码,缓存,权限等

      ```shell
      HTTP/1.0 200 OK 
      Content-Type: text/plain
      Content-Length: 137582
      Expires: Thu, 05 Dec 1997 16:00:00 GMT
      Last-Modified: Wed, 5 August 1996 15:55:28 GMT
      Server: Apache 0.84
      
      <html>
        <body>Hello World</body>
      </html>
      ```

      回应的格式是"头信息 + 一个空行（`\r\n`） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。

      **缺点**

      HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

      TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

      为了解决这个问题，有些浏览器在请求时，用了一个非标准的`Connection`字段。

      ```shell
      Connection: keep-alive
      ```

      这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。

 3. **HTTP/1.1 (1997年)**

    * 新增了许多动词方法: `PUT`、`PATCH`、`HEAD`、 `OPTIONS`、`DELETE`。

    * 客户端请求头新增`Host`字段,用来指定服务器域名

      ```shell
      Host: www.domain.com
      ```

    有了`Host`字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

    * 引入了持久连接,TCP连接默认不关闭,不用声明`Connection:keep-alive`;

    * 引入了pipelining,同一个TCP连接可以发送多个请求,进一步改进了HTTP协议的效率

    * 因为管道,TCP连接可以穿是那个多个回应,就必须要区分数据包是哪一个回应的,所以引入了`Content-Length`

      ```shell
      Content-Length: 3499
      ```

    * 使用`Content-Length`字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度,动态数据不断产生,意味着服务器要等待所有操作完成才知道`Conten-Length`,这太耗时了,参照流处理思路,服务器也希望有"流模式"(Stream)取代"缓存模式"(Buffer)

      所以1.1可以不使用`Content-Length`,采用分块传输,类似于flink中的window模式,一块一块的发,这种方式,需要请求或回应的头信息中有`Transfer-Encoding`字段,表示数据分块传输;

      ```shell
      Transfer-Encoding: chunked
      ```

      

      **缺点**

      虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为==队头堵塞==(Head-of-line blocking)

      避免队头堵塞的方法:

      1.减少请求数

      2.多开持久连接

      具体就是合并脚本和样式表,将图片嵌入CSS代码,域名分片

 4. **HTTP/2 (2015年)**

    为什么不叫2.0? 因为标准委员会不打算再发布子版本了,下一个版本叫HTTP/3;

    **HTTP/2的新特性**

    1. 二进制协议

    HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

    好处是，可以定义额外的帧,为将来的高级应用打好了基础.

    2. 多工

    HTTP/2复用TCP连接,客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

    3. 数据流

    因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

    HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

    数据流发送到一半的时候，客户端和服务器都可以发送信号（`RST_STREAM`帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

    客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

    4. 头信息压缩

    HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如`Cookie`和`User Agent`，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

    HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用`gzip`或`compress`压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

    5. 服务器推送

    HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

    常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

> **常见问题汇总**
>
> 1. keep-alive和非keep-alive的区别?
>
>    答: 早期HTTP/1.0中,每次发起HTTP请求结束都会立即关闭TCP连接,1.0版本为了减少创建和关闭连接的时间,请求头必须指定Connection: keep-alive来维持持久连接,
>
> 2. keep-alive的缺点?
>
>    答: 长时间的保持 TCP 连接时容易导致系统资源被无效占用，若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大,所以需要正确配置keep-alive_timeout参数;
>
> 3. keep-alive_timeout参数大小即Http长连接和短连接使用场景?
>
>    答: 长连接适用于操作频繁,点对点的通讯,如即时通讯,网络游戏等; 短连接适用于用户数量多的Web网站,例如京东淘宝等
>
> 4. 怎么知道HTTP报文长度?
>
>    答: HTTP/1.1版本的响应消息中存在Content-Length,就是报文长度,如果不存在,就表明数据是分块传输,Transfer-Encoding: chunked
>
> 5. HTTP是不保存状态的协议,如何保存用户状态?
>
>    * 基于Session
>
>      在服务器端创建一个Session对象以键值对形式存储用户信息,然后分配SessionID给客户端,这个会话存在客户端Cookie中,之后每次该浏览器发送HTTP请求都会带上Cookie中的SessionID到服务器,服务器根据SessionID就可以将之前存储的信息与本次会话关联起来,实现会话保持.
>
>      **优点**: 安全性高,因为状态信息只保存在服务器端
>
>      **缺点**: 遇到大型网站的HA设计,在做负载均衡的时候第二次分配到的服务器跟第一次不一样,则sessionID就匹配不上了;
>
>      [解决方案: 采用中间件Redis,所有服务器SessionID保存到Redis中,大型网站所有服务器共享Redis存储的Session信息,就可以避免上述问题]
>
>    * 基于Cookie
>
>      当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中
>
>      **优点**: 服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。
>
>      **缺点**: 该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽
>
>    * 如果Cookie被禁用
>
>      若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持,但是URL有长度限制,这个方法只能用于信息不多的情况下;

#### 1.2 HTTP方法简介

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求指定页面的信息并返回具体内容,通常只用于读取数据(select)  |
| HEAD    | 类似于GET,只不过返回的响应中没有内容,用于获取报头            |
| POST    | 用于提交数据进行处理请求(例如提交表单或上传文件),可能导致服务器资源变更(upload) |
| PUT     | 替换指定资源,没有的话就新增(insert overwrite)                |
| DELETE  | 请求服务器删除指定资源(delete)                               |
| OPTIONS | 向服务器获取指定资源所支持的HTTP请求方法                     |
| CONNECT | 将服务器作为代理,让服务器代替用户进行访问                    |
| TRACE   | 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断(debug) |
| PATCH   | 对PUT方法的补充,对已知资源进行局部更新(update)               |

> **常见问题汇总**
>
> 1. GET跟POST的区别?
>    * GET请求的参数包含在URL中(POST方法包含在请求主体中),URL记录会被保存在浏览记录中,可能存在安全问题;
>    * GET请求只支持URL编码,POST支持多种编码格式,GET通过URLEncode只支持ACSII,POST则没有限制
>    * GET请求参数数据有大小限制(针对浏览器而言),POST则没有限制
>    * GET方法需要使用Request.QueryString来获取参数,POST从Request.Form获取参数
>
> 2. GET的长度限制是多少?
>    * 不同浏览器不同,IE浏览器是2k多个字符,FireFox是65k多个字符,Google Chrom是8k个字符

#### 1.3 HTTP 状态码(标准情况下)

**在标准情况下(不考虑某些程序员个人原因或约定好的API返回码,比如某些返回状态0表示成功):**

HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。

HTTP 状态码共有 5 种类型：

| 分类 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| 1XX  | 状态信息--请求正在处理                                       |
| 2XX  | 成功--表示请求被处理完毕                                     |
| 3XX  | 重定向--该请求需要其他附加操作                               |
| 4XX  | 客户端错误--由于请求本身有语法问题或无法实现,服务器无法处理请求 |
| 5XX  | 服务端错误--服务器处理的时候出现错误                         |

详细的状态码列表:

| 状态码 | 英文简介                        | 中文描述                                                     |
| ------ | ------------------------------- | ------------------------------------------------------------ |
| 100    | Continue                        | 继续处理请求                                                 |
| 101    | Switching Protocol              | 切换协议。服务器根据客户端的请求切换到更高级的协议           |
| 200    | OK                              | 请求成功                                                     |
| 201    | Created                         | 请求成功,新的资源已经根据需求建立                            |
| 202    | Accepted                        | 请求已接受。已经接受请求，但还未处理完成                     |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器中，而是一个副本。 |
| 204    | No Content                      | 无内容。服务器成功处理了请求，但不需要返回任何实体内容       |
| 205    | Reset Content                   | 重置内容。与 204 类似，不同点是返回此状态码的响应要求请求者重置文档视图 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分 GET 请求                      |
| 300    | Multiple Choices                | 多种选择。被请求的资源有一系列可供选择的回馈信息，用户或浏览器能够自行选择一个首选地址进行重定向 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI |
| 302    | Found                           | 临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码 |
| 305    | Use Proxy                       | 使用代理。被请求的资源必须通过指定的代理才能被访问           |
| 306    | Unused                          | 在最新版的规范中，306状态码已经不再被使用                    |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解；请求的参数有误         |
| 401    | Unauthorized                    | 当前请求需要用户验证                                         |
| 402    | Payment Required                | 该状态码是为了将来可能的需求而预留的                         |
| 403    | Forbidden                       | 服务器已经理解请求，但是拒绝执行它,客户端没有权限等          |
| 404    | Not Found                       | 请求失败，请求所希望得到的资源未被在服务器上发现             |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体 |
| 407    | Proxy Authentication Required   | 与401响应类似，只不过客户端必须在代理服务器上进行身份验证    |
| 408    | Request Time-out                | 请求超时。服务器等待客户端发送的请求时间过长，超时           |
| 409    | Conflict                        | 由于和被请求的资源的当前状态之间存在冲突，请求无法完成       |
| 410    | Gone                            | 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址 |
| 411    | Length Required                 | 服务器拒绝在没有定义 Content-Length 头的情况下接受请求       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围 |
| 414    | Request-URI Too Large           | 请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务 |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
| 500    | Internal Server                 | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理 |
| 501    | Not Implemented                 | 服务器不支持当前请求所需要的某个功能                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应 |
| 503    | Service Unavailable             | 由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本           |

### 2. HTTPS协议

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。

==HTTPS连接的工作流程==

1. clinent发起一个HTTPS请求,连接到server的443端口,发送的主要信息包括自身所支持的加密算法和密钥长度等;
2. server从将自身所支持的算法与收到的client支持算法比较,选择一种共同支持的算法,将它和其他密钥组件发给client;
3. server向client发送一个包含数字证书的报文,该证书包括颁发机构,过期时间,server端公钥等信息;
4. 2,3步发送完成后,服务器发送一个完成报文,通知client第一阶段SSL协商完成
5. clinet收到完成报文后开始整理接收到的证书跟组件,使用证书公钥加密一个被称为pre_master_secre的随机密码串
6. 紧接着第5步,client会发送一个报文向server确认之后的报文都采用pre_master_secre加密
7. 5,6步完成之后还会发送一个finish报文,该报文包括第一次发起请求至今所有报文的整体校验值,最终协商是否完成取决于服务端能否成功解密。
8. server端同样发送pre_master_secre给client确认(用来保证两边都有同样的pre_master_secre),如果能够成功解密,则向client发送finish报文,告知client自己能成功解密,第7步成功

当双方的finish报文交换完成,SSL连接成功建立,之后进行的过程同HTTP通信过程,唯一不同的是HTTPS中的内容不是明文传输,采用了对称加密的方式,对称密钥在SSL过程中已经协商好了.

> **常见问题汇总**
>
> 1. HTTPS和HTTP的区别?
>
>    * HTTP协议以明文方式发送,安全性较差,HTTPS加密传输,安全性较好
>    * HTTP和HTTPS使用不同的连接方式,用的端口也不一样,HTTP 80端口,HTTPS是443端口
>    * HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。
>    * HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。
>
> 2. HTTPS的加密方式?
>
>    `**对称加密**就是加密和解密用的是同一个密钥k。`
>    `**非对称加密**是发送端使用公开的公钥a加密，然后接收端使用私密的私钥b解密`。
>
>    `对称加密快，非对称加密安全。对称加密如**DES**，非对称加密如**RSA**。`
>
>    HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程.
>
>    简而言之,SSL协商过程是非对称加密保证安全,传输过程是对称加密保证速度.

### 3. DNS

DNS(Domain Name System) 是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。简而言之就是一个根据域名查询IP地址的服务,可以理解成一个巨大的电话本.使用linux命令`dig`可以试着感受一下DNS查询过程:

```shell
dig www.baidu.com
; <<>> DiG 9.10.6 <<>> www.baidu.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 14498
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4000
;; QUESTION SECTION:
;www.baidu.com.			IN	A

;; ANSWER SECTION:
www.baidu.com.		102	IN	CNAME	www.a.shifen.com.
www.a.shifen.com.	396	IN	A	180.101.49.11
www.a.shifen.com.	396	IN	A	180.101.49.12

;; Query time: 0 msec
;; SERVER: 10.6.8.155#53(10.6.8.155)
;; WHEN: Wed Feb 24 10:21:01 CST 2021
;; MSG SIZE  rcvd: 101
```

返回两个A(Address)Ip和指向的另一个域名,可以再dig www.a.shifen.com来获得其他的IP;

#### 3.1 域名的层级

仔细看上面的例子,每个域名尾部都多了一个点

![image-20210224102738210](/Users/dinl/Library/Application Support/typora-user-images/image-20210224102738210.png)

这不是显示错误,而是所有域名之后都有一个==根域名roo==t,因为所有域名的根域名一样,所以通常不显示;

根域名的下一级,叫做==顶级域名==(top-level domain,缩写TLD),顶级域名,顶级表示了组织信息或国家信息: com/net/top是通用域名,org表示一些非盈利组织,edu表示教育组织;还有就是国家顶级域名(cn,uk,ca,jp等);

顶级域名的下一级,是==权威DNS==服务器,这一层域名是用户可以注册的,注册之后公共可访问,

![image-20210224105638341](/Users/dinl/Library/Application Support/typora-user-images/image-20210224105638341.png)

#### 3.2 DNS劫持

指的是将原域名对应的IP地址进行替换,导致用户访问到错误的网站或者无法正常访问的一种攻击方式.域名劫持通常只能在特定的网络范围内,攻击方式也很好理解, 就是冒充域名所属机构,通过电子邮件的方式修改域名或者将域名交给其他组织,并将新的域名信息保留到指定的DNS服务器上,使用户无法正常解析域名.

### 4. Socket套接字

socket是对网络中不同主机上的应用进程之间进行双向通信的断点的抽象,网络进程通信的一段就是一个套接字,不同主机之见通信就是通过套接字发送报文.比如TCP使用IP+端口号就是一个连接端点,这个端点就是套接字.

> **常见问题**
>
> 1. 套接字有哪些类型?
>    * 流套接字(SOCK_STREAM):  基于TCP协议,能保证数据不差不重,并且按顺序接收;
>    * 数据报套接字(SOCK_DGRAM): 基于UDP协议,不用建立长连接,发完就关闭连接,当然也不保证数据可靠性,应用程序需要处理丢包等问题;
>    *  原始套接字(SOCK_RAW): 用于传送非传输层数据包(比如ping命令的ICMP协议包)或操作系统无法处理的数据包;



### 5. FTP/TFTP协议

#### 5.1 FTP

FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。

#### 5.2 TFTP

FTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户/服务器方式，使用 UDP 数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定



### 6. 其他协议

#### 6.1 SMTP

SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25

#### 6.2 DHCP

DHCP ( Dynamic Host Configuration Protocol，动态主机设置协议 ) 是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：

1. 用于内部网络或网络服务供应商自动分配 IP 地址给用户

2. 用于内部网络管理员作为对所有电脑作中央管理的手段

   

### 7. 网页解析的完整过程

![image-20210224112755155](/Users/dinl/Library/Application Support/typora-user-images/image-20210224112755155.png)

① **DNS解析**: 当用户输入网址按下回车,浏览器会把输入的网址转换成实际的IP地址;

② **TCP连接**: 通过三次握手建立TCP连接

③ **发起HTTP请求**: 浏览器向服务器发起HTTP请求,建立请求的过程中可能设计负载均衡

④ **处理请求**: 服务器收到客户端的HTTP请求,根据请求内容作出相应处理,并把处理结果返回给客户端



## 三. 传输层

### 1. TCP协议

#### 1.1 什么是TCP协议

TCP(Transmission Control Protocol)传输控制协议,是传输层一种**面向连接**的,**可靠的**,**基于字节流**的协议,用来保证数据的可靠传输.

TCP位于应用层跟网络层之间,保证应用数据成功在网络之间的可靠传输.

> TCP并不能保证数据一定会被对方接收到,因为这是不可能的,如果有可能,就把数据传递给对方,实在没办法就放弃重传并且终端连接来通知用户,因此TCP并不是100%可靠的协议,它提供的是数据的可靠递送或故障的可靠通知.

那么TCP是如何保证数据传输的可靠性呢?

#### 1.2  TCP数据包的大小

![image-20210224164556659](/Users/dinl/Library/Application Support/typora-user-images/image-20210224164556659.png)

一个以太网数据包的大小固定为1522个字节;

>  1522 = 22(以太网Head) + 20(IP Head) + 20(TCP Head) +  1460(Data)

其中Data大小被称为TCP数据包的负载,因此TCP数据包最大负载是1460个字节,但是由于IP和TCP协议往往有额外的Head信息,所以实际负载在1400字节左右.

#### 1.3  TCP数据包编号

由于TCP一个数据包的负载大小是有限的(1400bit左右),那么一次性发送大量数据,比如10M的文件,就需要分包,为了方便接收方还原或者丢包的时候知道丢失是哪个包,

除了第一个包是随机数以外,后面每个包的编号都是前面一个包的编号+负载大小,比如一号包是1,包的负载是100个字节,那么紧接其后的二号包编号应该是101.为了保证可靠性,每个数据包都有自身编号,和下一个包的编号,这样接收方就可以如链表一般得到一个完整的数据包了,而且一旦数据大小对不上两个包编号的差,就能快速定位问题了.

对于分包组装来说,就是操作系统做的事情了,应用程序拿到的必定是操作系统组装好的完整10M数据包,对于操作系统来说,他做的也就是从第一个数据包开始,如同链表的顺序访问一般,按照下一个数据包编号把所有数据包组合好,然后按照TCP数据包里面的port参数,发给不同的应用程序,比如TCP数据包里面的port是80,而80端口是web服务复制监控的,web服务就会把数据包给到浏览器应用程序.

#### 1.4 慢启动和ACK

服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。

慢启动指的是服务器发送数据包的时候,由于事先不知道线路的理想速率,在刚开始的时候发的较慢,如果不丢包,就加快发送速度,如果丢包就降低发送速度.

Linux 内核里面[设定](http://elixir.free-electrons.com/linux/v4.5/source/include/net/tcp.h#L220)了（常量`TCP_INIT_CWND`），刚开始通信的时候，发送方一次性发送10个数据包，即"发送窗口"的初始大小为10。然后停下来，等待接收方的确认，再继续发送。

这种慢启动再由线路接受速率的操作是怎么做到的呢?  答案是ACK

默认情况下,接收方每收到两个数据包,就要发送一个确认"ackonwledgement"消息,简称ACK.

ACK携带两个消息

> * 期待收到的下一个数据包的编号(用来告诉服务器自己本包收到了多少数据)
> * 接收方的接收窗口缓存剩余(告诉服务器注意别发太快以免自己接收不过来)

服务器收到ACK信息,就可以推测接收方大概的网速,从而调整发送速率,调整好之后的固定速度,就是"发送窗口"的正常大小,该大小是可变的.

即便接收方带宽再高,TCP也总从10个数据包开始慢慢测试,过一段时间才达到最高传输速率,这就是整个慢启动.

#### 1.5 快重传和快恢复

快重传算法要求接收方每收到一个失序的报文就立即发送重复确认,而不是等到自己发送数据时才确认;

> 假如正确情况下,接收方应该收到Msg 1~4这四个报文,实际上收到Msg 1,Msg 3,Msg4,当收到Msg3的时候,接收端发现失序,立刻发送Msg1的序列号跟服务器确认,服务器收到立刻恢复到Msg1 开始重传,而不用等到发完四个包再重传,这一机制提高了网络的吞吐量.

#### 1.6 TCP连接建立时的三次握手

> 模拟情景: 
>
> 卢本伟: 听得到我说话吗?老,老铁(发出SYN=1,等待确认seq=x)
>
> 队友: 听得到(自己听到的消息是ACK=1,SYN=1),你听得见我说话吗(发送Ack=1,seq=y)
>
> 卢本伟: 我听得到(ACK=1),兄弟(Seq=x+1,Ack=y+1)
>
> 之后卢本伟开始跟队友聊自己的背包平底锅.....

![image-20210224173928956](/Users/dinl/Library/Application Support/typora-user-images/image-20210224173928956.png)

1. 客户端向服务器发送SYN=1请求,seq为x(SYN=1表示尝试建立连接)
2. 服务器收到并同意建立连接(ACK=1),向客户端发送SYN=1(服务器尝试向客户端建立连接),序列号为y,为了表示自己收到了seq,还要回复Ack=seq+1
3. 客户端同意建立连接(ACK=1),表示收到服务器端的确认号 Ack，并将其值作为自己的序号值(Seq=x+1),还要告诉对方自己收到了对方的序列号(Ack=y+1)

当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-SEND 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。

> **常见问题汇总**
>
> 1. 第一次握手失败会发生什么?
>
>    服务器没收到SYN=1,则不会做出任何回应,此时客户端请求重连,重连次数超过最大重传次数,会报错返回-1;
>
> 2. 第二次握手失败会发生什么?
>
>    若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文
>
> 3. 第三次握手失败会发生什么?
>
>    服务器会跟客户端一样失败重传,若超过重传次数,accept()系统调用返回-1,服务端连接建立失败.
>
> 4. 如果两次握手会怎么样?
>
>    第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。

#### 1.7 TCP连接关闭时的四次挥手

![image-20210224175613042](/Users/dinl/Library/Application Support/typora-user-images/image-20210224175613042.png)



1. 客户端向服务器发起请求(FIN=1)请求断开连接,并发送序列号Seq=u,自身从`ESTABLISHED`进入`FIN-WAIT-1`
2. 服务器收到FIN=1的请求断开连接报文后,结束`ESTABLISHED`阶段,进入`CLOSE-WAIT`(等待上层程序确认没有未发的数据)阶段,做好了释放连接准备后,发送报文给客户端,告知对方自己已经收到客户端的关闭连接请求,并让对方再等等,发送报文包括
   * ACK=1,收到客户端的FIN=1请求
   * 确认号为Ack=u+1,表示在已经收到服务器报文的基础上,将其序列号加1作为本段报文确认好Ack的值
   * 序列号为Seq=v
3. 服务器确认没有未发完的内容之后,向客户端发送请求FIN=1请求断开连接,标记位是1,序列号是w,Ack=u+1
4. 客户端回复ACK=1表示已经收到,Seq=u+1,将对方的Ack确认消息当做自己的序列号,并且确认号Ack为w+1,然后自己进入`TIME-WAIT`等待两个MSL(（Maximum Segment Lifetime)时间,如果没有收到服务器的消息,则客户端CLOSE,服务器收到此消息之后 也CLOSE连接,至此TCP连接关闭.

### 2. UDP协议

#### 	2.1 什么是UDP协议

UDP(User Datagram Protocol) 用户数据包协议是一种`无连接`,`面向报文`的传输协议.与TCP互为补充,UDP不保证传输的可靠性,只尽最大能力交付报文,所以主机不需要维持复杂的连接状态表,除此之外,UDP`没有拥塞控制`,不会因为网络拥塞,影响服务器的传送速度.

#### 	2.2 UDP跟TCP协议的区别

| 协议 | 是否面向连接 | 传输可靠性 | 传输形式   | 传输效率 | 所需资源 | 头部字节 | 应用场景          |
| ---- | ------------ | ---------- | ---------- | -------- | -------- | -------- | ----------------- |
| TCP  | 是           | 可靠       | 字节流     | 慢->稍快 | 多       | 20~60    | 文件传输,邮件传输 |
| UDP  | 否           | 不可靠     | 数据报文段 | 快       | 少       | 8        | 即时通信          |

## 四. 网络层

### 1. IP协议



